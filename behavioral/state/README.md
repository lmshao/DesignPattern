# 状态模式（State Pattern）

## 设计逻辑说明

本示例通过状态模式实现了一个音乐播放器系统，展示了如何让对象在其内部状态改变时改变其行为。状态模式将状态相关的行为封装在不同的状态类中，使对象看起来像是改变了其类。

- **State（状态接口）**：`PlayerState` trait，定义了状态的统一接口，包含 `play()`、`pause()`、`stop()` 方法，所有方法返回 `Result` 类型以处理无效操作。
- **ConcreteState（具体状态）**：
  - `StoppedState`（停止状态）：只能执行播放操作，其他操作返回错误
  - `PlayingState`（播放状态）：可以暂停或停止，重复播放返回错误
  - `PausedState`（暂停状态）：可以继续播放或停止，重复暂停返回错误
- **Context（上下文）**：`MusicPlayer` 结构体，管理当前状态和歌曲信息，所有操作方法都处理状态转换的错误。

## 运行效果

程序演示了音乐播放器的三种测试场景：
1. **正常播放流程**：停止 → 播放 → 暂停 → 播放 → 停止
2. **无效操作测试**：在错误状态下执行无效操作，返回详细错误信息
3. **错误处理演示**：使用 `match`、`if let` 等方式优雅处理状态转换错误

每次操作都会显示当前状态、执行结果和新状态。无效操作会返回 `StateError` 错误，而不是静默忽略，确保状态机的严格语义。

## 适用场景

状态模式适用于对象行为依赖于其状态，且需要在运行时根据状态改变行为的场景。例如：
- 媒体播放器：根据播放状态控制播放、暂停、停止操作
- 文档编辑器：根据编辑模式（查看、编辑、只读）执行不同操作
- 游戏角色：根据角色状态（正常、受伤、死亡）执行不同动作
- 订单系统：根据订单状态（待付款、已付款、已发货）执行不同操作
- 网络连接：根据连接状态（断开、连接中、已连接）处理不同请求
- 工作流引擎：根据流程状态控制下一步可执行的操作 