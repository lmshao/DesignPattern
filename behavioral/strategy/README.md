# 策略模式（Strategy Pattern）

## 设计逻辑说明

本示例通过策略模式实现了一个简单的支付系统，展示了如何将算法封装为对象，使其可以在运行时互换。策略模式将"怎么做"与"做什么"完全分离。

- **PaymentStrategy（策略接口）**：`PaymentStrategy` trait/interface，定义了支付算法的统一接口，包含 `pay()`（支付）和 `get_name()`（获取名称）方法。
- **ConcreteStrategy（具体策略）**：
  - `CreditCardPayment`（信用卡支付）：封装信用卡支付逻辑
  - `PayPalPayment`（PayPal支付）：封装PayPal支付逻辑
- **Context（上下文）**：`PaymentContext` 结构体，管理支付策略的设置和执行，不需要了解具体的支付实现细节。

## 运行效果

程序演示了支付系统的核心场景：
1. **策略切换**：在运行时动态切换不同的支付方式
2. **统一接口**：所有支付方式都通过相同的接口调用
3. **独立封装**：每种支付方式的具体逻辑完全独立

每次支付都会显示所使用的支付方式和处理过程，清晰展示策略模式的"算法可替换"特性。

## 适用场景

策略模式适用于需要在运行时选择不同算法的场景，特别是当算法经常变化或需要支持多种算法时。例如：
- 支付系统：支持多种支付方式（信用卡、PayPal、数字货币等）
- 排序算法：根据数据规模选择不同的排序策略
- 数据压缩：根据文件类型选择不同的压缩算法
- 游戏AI：根据难度级别选择不同的AI策略
- 图像处理：根据需求选择不同的滤镜算法 